# Cursor Project Bootstrap ‚Äî Railway + Netlify + GitHub
# Filetype: .mdc (Model Directive for Cursor)

## üß≠ Purpose
Make Cursor default to this stack whenever I say things like ‚Äústart a new project‚Äù or ‚Äúscaffold a repo‚Äù:
- **Backend** on **Railway** (Node/Express by default) with optional **PostgreSQL**
- **Frontend** on **Netlify** (Vite React by default)
- **Repo** on **GitHub** under **tuesdayconcepts** org (unless otherwise specified)
- Shared CI/CD via GitHub Actions; environment variables wired end‚Äëto‚Äëend

---

## üéõÔ∏è Global Behavior
1. Prefer **TypeScript** for both client and server unless I say otherwise.
2. Use a **monorepo**: `/server` (backend, Railway) and `/client` (frontend, Netlify).
3. Always create `.env.example` files with sensible defaults and comments.
4. Use **PostgreSQL** via `DATABASE_URL` when I mention a DB, and scaffold migrations.
5. Keep diffs minimal; match existing lint/format configs if present.
6. Produce a short README with run, env, and deploy instructions.

---

## üß© When I say ‚Äúnew project ‚Ä¶‚Äù
**If I say:** ‚ÄúStart a new project called X‚Äù (optionally I may specify stack variants)
1. Create this structure:
```
{{PROJECT_NAME}}/
‚îú‚îÄ client/        # Netlify app (React + Vite, TypeScript)
‚îú‚îÄ server/        # Railway API (Express + TypeScript)
‚îú‚îÄ .github/workflows/deploy.yml
‚îú‚îÄ README.md
```
2. Initialize Git and **assume GitHub**: `https://github.com/tuesdayconcepts/{{PROJECT_NAME}}` (ask before creating if repo doesn‚Äôt exist).
3. Generate the files below (fill {{‚Ä¶}} placeholders).

---

## üóÑÔ∏è Backend (Railway)
**Assumptions:**
- Node 20+, Express, TypeScript, `ts-node` / build to `dist/`
- `PORT` from env, default 8080
- Optional Postgres with `DATABASE_URL`

**server/package.json**
```json
{
  "name": "{{PROJECT_NAME}}-server",
  "private": true,
  "type": "module",
  "engines": { "node": ">=20" },
  "scripts": {
    "dev": "tsx src/index.ts",
    "build": "tsc -p tsconfig.json",
    "start": "node dist/index.js",
    "lint": "eslint .",
    "format": "prettier -w ."
  },
  "dependencies": {
    "express": "^4.19.2",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/cors": "^2.8.17",
    "tsx": "^4.16.2",
    "typescript": "^5.6.3",
    "eslint": "^9.10.0",
    "prettier": "^3.3.3"
  }
}
```

**server/tsconfig.json**
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "outDir": "dist",
    "rootDir": "src",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true
  },
  "include": ["src"]
}
```

**server/src/index.ts**
```ts
import "dotenv/config";
import express from "express";
import cors from "cors";

const app = express();
app.use(cors());
app.use(express.json());

app.get("/health", (_req, res) => {
  res.json({ ok: true, service: "{{PROJECT_NAME}}-server" });
});

// Example CRUD placeholder
app.get("/api/v1/items", (_req, res) => {
  res.json([{ id: 1, name: "example" }]);
});

const port = process.env.PORT ? Number(process.env.PORT) : 8080;
app.listen(port, () => {
  console.log(`API listening on :${port}`);
});
```

**server/.env.example**
```
# Set by Railway
PORT=8080

# Optional Postgres (Railway will inject this automatically if you add a Postgres plugin)
DATABASE_URL=postgresql://USER:PASSWORD@HOST:PORT/DBNAME?sslmode=require
```

**server/railway.json**
```json
{
  "$schema": "https://railway.app/railway.schema.json",
  "services": [
    {
      "name": "backend",
      "source": "server",
      "envVars": {
        "PORT": "8080"
      }
    }
  ],
  "plugins": [
    {
      "name": "PostgreSQL",
      "env": "DATABASE_URL"
    }
  ]
}
```

**server/Dockerfile**
```dockerfile
# Railway supports Docker or Nixpacks; this Dockerfile is explicit.
FROM node:20-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci

FROM node:20-alpine AS build
WORKDIR /app
COPY --from=deps /app/node_modules node_modules
COPY . .
RUN npm run build

FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production
COPY --from=build /app/node_modules node_modules
COPY --from=build /app/dist dist
EXPOSE 8080
CMD ["node", "dist/index.js"]
```

**server/nixpacks.toml**
```toml
# Nixpacks configuration for Railway deployment
[phases.setup]
nixPkgs = ["nodejs_20"]

[phases.install]
cmds = ["npm ci"]

[phases.build]
cmds = ["npm run build"]

[start]
cmd = "npm start"
```

**railway.toml** (in repo root)
```toml
# Railway configuration for monorepo
[build]
builder = "NIXPACKS"

[deploy]
restartPolicyType = "ON_FAILURE"
restartPolicyMaxRetries = 10

[deploy.healthcheck]
path = "/health"
timeout = 10
```

> **Railway Deployment Note:** In Railway dashboard, set **Root Directory** to `server` under Settings ‚Üí Build. This tells Railway to build from the server folder in the monorepo.

> **If I request Prisma:** add `prisma/schema.prisma`, `npx prisma init`, and example migration + CRUD route wired to `DATABASE_URL`.

---

## üåê Frontend (Netlify)
**client/package.json**
```json
{
  "name": "{{PROJECT_NAME}}-client",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "lint": "eslint .",
    "format": "prettier -w ."
  },
  "dependencies": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "typescript": "^5.6.3",
    "vite": "^5.4.6",
    "@vitejs/plugin-react": "^4.3.1",
    "@types/react": "^18.3.7",
    "@types/react-dom": "^18.3.0",
    "eslint": "^9.10.0",
    "prettier": "^3.3.3"
  }
}
```

**client/vite.config.ts**
```ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
})
```

**client/tsconfig.json**
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}
```

**client/src/vite-env.d.ts**
```ts
/// <reference types="vite/client" />

// Declare Vite environment variables with proper types
interface ImportMetaEnv {
  readonly VITE_API_URL: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}
```

**client/index.html**
```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üöÄ</text></svg>" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{{PROJECT_NAME}}</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

**client/src/main.tsx**
```tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
```

**client/src/App.tsx**
```tsx
/// <reference types="vite/client" />
import { useState, useEffect } from 'react'
import './App.css'

// Get API URL from environment variable
const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8080'

function App() {
  const [items, setItems] = useState<Array<{ id: number; name: string }>>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  // Fetch items from API on component mount
  useEffect(() => {
    fetch(`${API_URL}/api/v1/items`)
      .then(res => res.json())
      .then(data => {
        setItems(data)
        setLoading(false)
      })
      .catch(err => {
        setError(err.message)
        setLoading(false)
      })
  }, [])

  return (
    <div className="app">
      <h1>{{PROJECT_NAME}}</h1>
      <div className="card">
        {loading && <p>Loading...</p>}
        {error && <p className="error">Error: {error}</p>}
        {!loading && !error && (
          <ul>
            {items.map(item => (
              <li key={item.id}>{item.name}</li>
            ))}
          </ul>
        )}
      </div>
    </div>
  )
}

export default App
```

**client/src/App.css**
```css
.app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
  margin-bottom: 2rem;
}

.card {
  padding: 2em;
  background-color: #1a1a1a;
  border-radius: 8px;
}

ul {
  list-style: none;
  padding: 0;
}

li {
  padding: 0.5rem;
  margin: 0.5rem 0;
  background-color: #2a2a2a;
  border-radius: 4px;
}

.error {
  color: #ff6b6b;
}
```

**client/src/index.css**
```css
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

#root {
  width: 100%;
}
```

**client/.env.example**
```
# Netlify exposes only variables prefixed with VITE_ to the client
VITE_API_URL=https://{{RAILWAY_BACKEND_DOMAIN}}   # e.g., https://{{PROJECT_NAME}}.up.railway.app
```

**netlify.toml** (in repo root)
```toml
[build]
  base = "client"
  command = "npm ci && npm run build"
  publish = "dist"  # Relative to base directory

[dev]
  command = "npm run dev"
  port = 5173
```

---

## üîó Wiring & Conventions
- **API URL**: Frontend uses `import.meta.env.VITE_API_URL`. Set this in **Netlify** to your Railway public URL.
- **Database**: When Postgres is used, Railway provides `DATABASE_URL`. Code must **not** hard‚Äëcode credentials.
- **Health check**: Backend exposes `/health` for readiness probes and debugging.

---

## ü§ñ CI/CD ‚Äî GitHub Actions
**.github/workflows/deploy.yml**
```yaml
name: Deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  backend:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: server
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: npm ci
      - run: npm run build
      # Deploy via Railway CLI (requires token)
      - name: Install Railway CLI
        run: npm i -g @railway/cli
      - name: Link & Deploy
        env:
          RAILWAY_TOKEN: \${{ secrets.RAILWAY_TOKEN }}
        run: |
          railway up --service backend

  frontend:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: client
    needs: backend
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: npm ci
      - run: npm run build
      - name: Deploy to Netlify
        uses: netlify/actions/cli@v4.0.1
        with:
          args: deploy --dir=dist --prod
        env:
          NETLIFY_AUTH_TOKEN: \${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: \${{ secrets.NETLIFY_SITE_ID }}
```

> Store secrets in GitHub: `RAILWAY_TOKEN`, `NETLIFY_AUTH_TOKEN`, `NETLIFY_SITE_ID`. Keep `DATABASE_URL` only in Railway and never commit it.

---

## üìò README seed
Generate a concise README with:
- Local dev: how to run server & client, and set `VITE_API_URL`
- Env vars: list and where to set (Railway vs Netlify vs GitHub)
- Deploy steps: CLI commands + CI/CD overview
- Links: GitHub repo slug, Railway service URL, Netlify site URL

---

## üß™ Quick Commands (insert as needed)
```bash
# Monorepo init
git init && git add . && git commit -m "chore: bootstrap"

# Create GitHub repo (confirm org and name)
gh repo create tuesdayconcepts/{{PROJECT_NAME}} --public --source=. --remote=origin
git push -u origin main

# Railway
npm i -g @railway/cli
railway login
railway init
railway up   # deploy backend; add Postgres plugin if needed

# Netlify
npm i -g netlify-cli
netlify login
cd client && netlify init   # link or create site, set VITE_API_URL in dashboard
netlify deploy --build --prod
```

---

## üó£Ô∏è Assistant Prompts (what Cursor should proactively do)
- ‚ÄúWhen I say *start a new project called X*, scaffold everything above with placeholders filled.‚Äù
- ‚ÄúWhen I say *deploy*, output the exact CLI commands for Railway and Netlify, and verify env variables.‚Äù
- ‚ÄúWhen I say *add database*, add Prisma (or SQL library I specify), generate migration boilerplate, and wire `DATABASE_URL`.‚Äù
- ‚ÄúWhen I say *generate README*, create the README per the template.‚Äù

---

## üîÅ Variants (if I change framework)
- **Backend Python/FastAPI**: use `uvicorn`, `requirements.txt`, `Dockerfile`, same env and Railway wiring.
- **Frontend Next.js**: update `netlify.toml` build command and output detection accordingly.

---

## ‚úÖ Success Criteria
- Running `railway up` deploys the server and health check returns 200.
- Netlify site builds successfully and consumes `VITE_API_URL`.
- GitHub Actions workflow passes on `main` and can trigger both deploys.
- README shows clear local + prod instructions.
- Zero console errors (no missing favicon, TypeScript errors, or CORS issues).

---

## üîß Troubleshooting Common Issues

### Railway Build Failures

**Issue:** "Nixpacks could not determine how to build the app"
- **Solution:** Set **Root Directory** to `server` in Railway Settings ‚Üí Build

**Issue:** "npm: command not found" during build
- **Solution:** Ensure `server/nixpacks.toml` exists with Node.js configuration

**Issue:** TypeScript error "Could not find declaration file for module 'cors'"
- **Solution:** Add `@types/cors` to `devDependencies` in `server/package.json`

### Netlify Build Failures

**Issue:** "Property 'env' does not exist on type 'ImportMeta'"
- **Solution:** Ensure `client/src/vite-env.d.ts` exists with proper type definitions

**Issue:** "404 Not Found" for published site
- **Solution:** Verify `publish = "dist"` in `netlify.toml` (not `client/dist`)

**Issue:** Missing favicon causing 404 errors
- **Solution:** Add inline SVG favicon to `index.html` as shown in template

### Environment Variables

**Issue:** Frontend can't connect to backend
- **Solution:** Set `VITE_API_URL` in Netlify dashboard (Site Configuration ‚Üí Environment variables)

**Issue:** Backend not responding on Railway
- **Solution:** Verify Railway assigned a public domain (Settings ‚Üí Networking ‚Üí Generate Domain)

---

## üöÄ Deployment Checklist

When deploying a new project, follow this order:

1. ‚úÖ Push code to GitHub
2. ‚úÖ Deploy backend to Railway:
   - Connect GitHub repo
   - Set Root Directory to `server`
   - Wait for build to complete
   - Generate public domain
3. ‚úÖ Deploy frontend to Netlify:
   - Connect GitHub repo
   - Verify build settings (base: `client`, publish: `dist`)
   - Set `VITE_API_URL` environment variable with Railway URL
   - Trigger deploy
4. ‚úÖ Test the app:
   - Visit Netlify URL
   - Check browser console for errors
   - Verify API calls work
5. ‚úÖ Optional: Setup GitHub Actions secrets for CI/CD

